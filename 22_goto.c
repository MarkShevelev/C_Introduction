/**
 * Во многих реальных задачах возникает необходимость совершать повторяющиеся 
 * действия, возвращаться к тем участкам кода, которые уже были пройдены.
 * В этих случаях требуется специальный языковой механизм. В языке C 
 * для этого предлагаются два варианта: циклы и безусловный переход.
 * Далее будет рассмотрен безусловный переход к меткам, оператор goto.
 */

#include <stdio.h>
#include <stdbool.h>

int main() {
    /**
     * Рассмотрим простую задачу.
     * Напечатать на экране фразу Hello! 10 раз.
     * Её можно выполнить тривиальным способом, набрав 10 раз printf("Hello!\n");
     */
    if (false) //чтобы использовать этот фрагмент кода замените на 1 или true
    { 
        printf("Hello!\n");
        printf("Hello!\n");
        printf("Hello!\n");
        printf("Hello!\n");
        printf("Hello!\n");
        printf("Hello!\n");
        printf("Hello!\n");
        printf("Hello!\n");
        printf("Hello!\n");
        printf("Hello!\n");
    }

    /**
     * Если распечатать фразу придётся не 10 раз, а 1000?
     * Или кол-во раз будет заранее неизвестно!
     * Рассмотрим задачу: напечать на экране фразу Hello! столько раз, сколько затребует пользователь.
     */
    if (false) //чтобы использовать этот фрагмент кода замените на 1 или true
    {
        int count = 0; //переменная хранит кол-во раз, которое необходимо напечатать фразу Hello!
        scanf("%d",&count);

    NEXT: //метка! Идентификатор со знаком двоеточие (:)
        printf("Hello!\n"); //фрагмент кода, который следует повторить
        --count; //мы напечатали один раз, теперь осталось на один меньше
        if (0 != count) //пока есть что печатать, мы должны продолжать
            goto NEXT; //возвращаемся к отметке NEXT
        //к этой строке исполнение придёт, только если count == 0
    }

    /**
     * Сам по себе goto перебрасывает исполнение в любую точку кода, 
     * точнее к тем statement, которые отмечены. 
     * Метка - это идентификатор и двоеточие, которые ставятся в начале statement.
     * Рассмотрим задачу о Сиракузской последовательности.
     * Начинается последовательность с некоторого целого положительного числа.
     * Каждое последующее число вычисляется так:
     *     если a(N) чётно, то a(N+1) = a(N)/2
     *     если a(N) нечётно, то a(N+1) = 3*a(N) + 1
     * 
     * Для всех начальных чисел, для которых удалось эту последовательность рассчитать, 
     * она закачивается повторяющимся рядом 1 4 2 1. Однако ни количество шагов, ни 
     * наибольшее число в последовательности не известно.
     * Используем механизм перехода по метке (goto) для вычисления длины последовательности 
     * и максимального значения элементов.
     */
    if (false)//чтобы использовать этот фрагмент кода замените на 1 или true
    {
        int a = 53; //первый член последовательности
        unsigned count = 0; //счётчик элементов
        int max = a; //максимальный член последовательности, инициализируем первым членом, если он не максимальный, то переменная будет перезаписана
    NEXT_TERM:
        a = a%2 ? 3*a + 1 : a/2; //нам не требуется хранить промежуточное значение, мы перезаписываем переменную значением следующего члена последовательности
        max = a > max ? a : max; //если текущее значение максимума меньше следующего члена, перезаписываем в max новое значение, иначе - оставляем старое
        ++count; //следующий член последовательности получен - увеличиваем счётчик
        if (1 != a)
            goto NEXT_TERM; //если не дошли до единицы, то продолжаем ...

        printf("Number of elements = %u, maximum = %d\n", count, max); //не забываем про правильные местозаместители: %u - тип unsigned и %d - тип int
    }

    /**
     * goto можно использовать не только для того, чтобы венуться по коду назад, 
     * но и для того, чтобы пропустить часть кода. Чаще всего это используется в тех случаях, 
     * когда исполнения кода зависит от ряда условий. Например мы хотели бы разделить с остатком 
     * неотрицательное число на положительное.
     */
    if (false)//чтобы использовать этот фрагмент кода замените на 1 или true
    {
        int nominator, denominator; //числитель и знаменатель
        printf("Please, enter a nonegative integer number: ");
        fflush(stdout);
        scanf("%d",&nominator); //числитель должен быть неотрицательным для нашего расчёта
        if (0 > nominator) goto ERROR; //если числитель не удовлетворяет требованиям, отправляемся за пределы вычислений

        printf("Please, enter a positive integer number: "); //знаменатель должен быть положительным
        fflush(stdout);
        scanf("%d",&denominator);
        if (0 >= denominator) //если знаменатель не удовлетворяет требованиям, отправляемся за пределы вычислений
            goto ERROR;

        //если мы дошли до этой точки, то можем все условия выполнены и мы можем приступать к вычислениям
        printf("%d/%d = (%d,%d)\n",nominator,denominator,nominator/denominator,nominator%denominator);
        goto END; //перескакиваем сообщение об ошибке

    ERROR:
        printf("Wrong input data!\n");
    END:;
    }

    return 0;
}