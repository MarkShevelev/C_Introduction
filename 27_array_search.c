/**
 * Одна из распространённых задач, которая возникает при работе 
 * с однотипными данными - поиск, поиск определённых значений в 
 * наборе. Наиболее простым способом поиска является "линейный" поиск, 
 * суть которого в простом переборе всех данных. Иной способ - 
 * "бинарный" поиск, однако в этом случае данные должны быть специально 
 * подготовлены
 */

#include <stdio.h>
#include <stdbool.h>

int main() {
    /**
     * Создадим целочисленный массив и инициализируем его набором значений.
     * Попытаемся отыскать в нём заданное число.
     */
    if (false) 
    {
        int const haystack[10] = {5,7,4,3,8,9,0,1,2,6}; //линейный поиск не предъявляет никаких предварительных требований к данным
        int const needle = 0; //искомое число
        int found_idx = 0; //индекс первого совпадения
        for (; found_idx != 10; ++found_idx)
            if (needle == haystack[found_idx])
                break; //специальное ключевое слово, которое позволяет мгновенно покинуть цикл
        if (10 == found_idx) //если при обходе мы проверили каждый элемент в массиве и вышли за его пределы, то совпадения просто нет!
            printf("The number %d has not been found...\n",needle);
        else
            printf("The number %d is found at %d postion!\n",needle,found_idx);
    }

    /**
     * Линейный поиск или простой перебор удобны при небольшом кол-ве данных. 
     * Линейный поиск прост и не требует специально подготовленных данных.
     * Однако при большом количестве данных линейный поиск становится затратным!
     * Одним из методов ускорения поиска является алгоритм бинарного поиска.
     */
    if (false) 
    {
        int const haystack[10] = {0,2,3,5,6,8,9,11,13,14}; //бинарный поиск требует, чтобы данные были упорядочены!
        int const needle = 15; //искомое число
        int left = 0, right = 10; 
        /**
         * Искомое число находится где-то между левым и правым отсечками.
         * Отсечки описывают полуинтервал [left,right), т.е.
         * Искомое число всегда больше или равно значению в отсечке left,
         * но всегда строго меньше значения в отсечке right.
         * Изначально мы выбираем в качестве отсечки right запрещённый индекс, 
         * словно бы за границей массива находится ещё одно число, самое большое.
         */
        while (left + 1 < right) { //пока между left и right больше одного числа, продолжаем поиск 
            int middle = (left + right)/2; //индекс опорного элемента
            if (needle < haystack[middle]) //если число меньше значения в опорном элементе
                right = middle;            //согласно полуинтервалу границ middle - это правая граница
            else
                left = middle;  //иначе левая...
        }
        if (needle == haystack[left]) //мы знаем, что число больше или равно значению в позиции left, следовательно нужно проверить совпадение
            printf("The number found %d at position %d\n", needle, left);
        else
            printf("The number %d not found\n",needle);

        /**
         * Данный вид поиска позволяет обнаружить искомый элемент, 
         * либо указать, что такого элемента нет в наборе, за 
         * O(log(N)) действий, т.к. на каждом шаге мы уменьшаем 
         * полуинтервал [left,right) вдвое.
         * Недостаток бинарного поиска - упорядоченность данных!
         */
    }

    return 0;
}