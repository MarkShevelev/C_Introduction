/**
 * В некоторых ситуациях между переменными нет 
 * разницы с точки зрения тех действий, которые мы 
 * над ними производим. В подобных ситуациях обращаться
 * к переменным по индивидуальным именам становится 
 * неудобно. Код оказывается громоздким и слабо понятным.
 * Выходом из этой проблемы являются массивы!
 * Для использования массивов не нужно подключать никаких 
 * специальных заголовков.
 */

#include <stdio.h>
#include <stdbool.h>

int main() {
    /**
     * Рассмотрим задачу.
     * Задана температура на каждый день недели.
     * Требуется узнать среднюю за неделю температуру и самое низкое значение.
     */
    if (false) 
    {
        float mon = 12.1f, tue = 10.3f, wed = 9.8f, thu = 9.5f, fri = 9.9f, sat = 10.1f, sun = 10.8f;
        float avg = (mon + tue + wed + thu + fri + sat + sun)/7.f; //мы явно просуммировали все переменные
        printf("Average temperature is %f\n",avg);

        //сложнее обстоит дело с поиском самой низкой... придётся явно написать сравнение с каждым днём недели
        float min_temp = mon; //предположим, что в понедельник была самая низкая температура
        if (tue < min_temp) min_temp = tue; //если во вторник температура ниже, наше предположение неверно, исправимся
        if (wed < min_temp) min_temp = wed;
        if (thu < min_temp) min_temp = thu;
        if (fri < min_temp) min_temp = fri;
        if (sat < min_temp) min_temp = sat;
        if (sun < min_temp) min_temp = sun; //для каждого дня недели нам пришлось 
        printf("Minimal temperature is %f\n",min_temp);
    }

    /**
     * Массивы позволяют нам объединить под одним именем несколько переменных.
     * Обращение к этим переменным будет осуществляться по индексу, номеру.
     * Это позволит нам унифицировать работу с такими данными, как множества значений 
     * одной величины.
     */
    //решение задачи о средней и минимальной температуре с использованием массива
    if (false) 
    {
        float week_temp[7]; //объявление массива из 7 переменных типа float, по одной на день недели, с общим названием week_temp
        week_temp[0] = 12.1f; //при обращении к элементам массива используются квадратные скобки, счёт начинается с нуля!
        week_temp[1] = 10.3f;
        week_temp[2] = 9.8f;
        week_temp[3] = 9.5f;
        week_temp[4] = 9.9f;
        week_temp[5] = 10.1f;
        week_temp[6] = 10.8f; //наибольший допустимый индекс - 6 для массива из семи элементов
        //week_temp[7] = 0.f; //неопределённое поведение!!! обращение к элементу за пределами массива!!!
        float avg = 0.f;
        for (int counter = 0; 7 != counter; ++counter) //цикл for позволяет нам в заголовке опрделить и переменную для обращения к элементам, и условие, и увеличение индекса 
            avg += week_temp[counter]; //counter пробегает все допустимые индексы, в переменной avg аккумулируются значения
        avg /= 7.f;
        printf("Average temperature is %f\n",avg);

        /**
         * Алгоритм суммирования с использованием цикла позволяет найти среднее любого количества 
         * элементов без существенного изменения (изменится только предел перебора индекса).
         * Похожим образом упрощается и поиск минимальной температуры.
         */
        float min_temp = week_temp[0];
        for (int counter = 1; 7 != counter; ++counter)
            min_temp = week_temp[counter] < min_temp ? week_temp[counter] : min_temp; //если температура последующего дня ниже предполагаемого минимума, то заменяем значение минимума
    
        printf("Minimal temperature is %f\n",min_temp);
    }

    /**
     * Всегда, когда мы видим работу с однотипными элементами, 
     * следует использовать массивы. В таких ситуациях мы 
     * сразу видим, что при переходе от одной переменной к 
     * другой не меняются действия, которые мы с ними совершаем.
     * Рассмотрим задачу.
     * Петя и Паша выкладывают из цветных кирпичей пирамидальную стену.
     * Каждый кирпич может быть одного из трёх цветов: красный, зелёный или синий.
     * Сначала выкладывается линия основания. Следующий слой выкладывается так, 
     * чтобы каждый кирпич опирался на два соседних кирпича нижнего слоя.
     * Цвета кирпичей определяются по правилу: если цвета соседних кирпичей одинаковы, 
     * то и верхний кирпич будет того же цвета, если цвета разные, то верхний кирпич 
     * будет третьего, дополняющего цвета.
     * Обозначим цвета: R - красный, G - зелёный, B - синий.
     * Пример верной пирамиды с основанием длины 4:
     *    G
     *   G G
     *  B R B
     * R G B B
     * 
     * Нам необходимо написать программу, которая рассчитает цвет кирпича 
     * на вершине прирамиды по известному основанию.
     */
    if (false) 
    {
        /**
         * Очевидно, что описанный выше алгоритм нахождения цвета верхнего 
         * кирпича никак не зависит ни от номера ряда, ни от номера кирпича 
         * в ряду. Это сразу говорит о том, что здесь необходимо воспользоваться 
         * массивом! Будем обозначать цвета символами, заведём массив символов.
         */
        char base[4] = {'R', 'G', 'B', 'B'}; //посредством фигурных скобок можно при объявлении инициализировать массив
        /**
         * Учитывая, что нам не нужно сохранять данные о промежуточных кирпичах и 
         * что в каждом ряду кирпич с номером k влияет только на кирпичи с номерами 
         * k и k-1, мы можем выполнять все вычисления прямо в нашем массиве base.
         * Рассмотрим шаг для получения последующего ряда из предыдущего.
         */
        for (int k = 0; 3 != k; ++k) { //мы производим рассчёт только для индексов 0,1 и 2, потому что в следующем ряду на один кирпич меньше
            if (base[k] != base[k+1]) { //вычисления нужно провдить, только если цвета соседних кирпичей разные, иначе цвет не меняется
                switch(base[k+1]) {
                    //каждый case проверяет цвет последующего кирпича
                    case 'R': base[k] = 'B' == base[k] ? 'G' : 'B'; break; //условие проверяет цвет текущего кирпича, а зная цвет последуюего из case, мы можем рассчитать новый цвет
                    case 'B': base[k] = 'R' == base[k] ? 'G' : 'R'; break;
                    case 'G': base[k] = 'R' == base[k] ? 'B' : 'R'; break;
                }
            }
        }

        for (int k = 0; 3 != k; ++k)
            printf("%c ",base[k]); //для вывода отдельного символа, переменной типа char, в printf используется местозаместитель %c
        printf("\n");
    }

    /**
     * Далее нам следует повторить эту процедуру для всех рядов.
     * Мы можем ввести переменную length, которая будет 
     * отсчитывать длину ряда. С каждым новым уровнем длина ряда 
     * будет уменьшаться на единицу. Как только она достигнет нуля, 
     * мы прекратим цикл и выведем первый элемент массива - это и 
     * будет вершина пирамидальной стены!
     */
    if (false) 
    {
        char base[4] = {'R', 'G', 'B', 'B'}; 
        for (int length = 3; 0 != length; --length) {
            for (int k = 0; length != k; ++k) { 
                if (base[k] != base[k+1]) { 
                    switch(base[k+1]) {
                        case 'R': base[k] = 'B' == base[k] ? 'G' : 'B'; break; 
                        case 'B': base[k] = 'R' == base[k] ? 'G' : 'R'; break;
                        case 'G': base[k] = 'R' == base[k] ? 'B' : 'R'; break;
                    }
                }
            }
            //для диагностики оставлен вывод каждого отдельного ряда, без нарушения работы программы, вывод можно убрать
            for (int k = 0; length != k; ++k)
                printf("%c ",base[k]);
            printf("\n");
        }
        printf("The pyramid top color is %c\n",base[0]);
    }
    return 0;
}