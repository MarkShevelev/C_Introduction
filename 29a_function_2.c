/**
 * Мы знаем, что функции - это поименованные блоки 
 * кода. Функции могут принимать данные и могут возвращать 
 * данные. Функции могут использовать общие данные 
 * посредством глобальных переменных.
 * Далее рассмотрим:
 * 1 - использование ключевого слова return для прерывания 
 * работы функции
 * 2 - передачу массива в качестве параметра
 */

#include <stdio.h>
#include <stdbool.h>

/**
 * Если мы хотим вернуть какое-либо значение из 
 * функции, то внутри функции мы используем 
 * ключевое слово return. Важно знать, что 
 * ключевое слово return не просто устанавливает 
 * желаемые результат, но и полностью завершает 
 * работу функции. Рассмотрим функцию, которая 
 * находит площать треугольника по трём сторонам.
 * Если три значения не удовлетворяют неравенству 
 * треугольника, то функция возвращает ноль.
 */
#include <math.h>
float triangle_area(float a, float b, float c) {
    //формулу Герона можно использовать только тогда, когда выполнено неравество треугольника!
    if (a+b>c && b+c>a && a+c>b) {
        float p = (a+b+c)/2.f;
        return sqrt((p-a)*(p-b)*(p-c)*p);
    } //если неравенство невыполнено, возвращаем ноль
    else
        return 0;
}

/**
 * Функцию triangle_area можно переписать короче, 
 * воспользовавшись тем, что ключевое слово 
 * return сразу прерывает исполнение, как только 
 * исполнение его достигает.
 */
float triangle_area_variation(float a, float b, float c) {
    if (a+b<=c || b+c<=a || a+c<=b)//неравенство треугольника не выполнено
        return 0; //сработает return, исполнение будут преостановлено, и код не достигнет строчке 46-47, т.е. не будет пытаться вычислять площадь
    float p = (a+b+c)/2.f;
    return sqrt((p-a)*(p-b)*(p-c)*p);
}

/**
 * return можно использовать для мгновенного 
 * прерывания циклов внутри функции. Рассмотрим 
 * алгоритм "грубой силы" для проверки числа на 
 * простоту.
 */
bool is_prime(unsigned N) {
    bool isp = true; //предполагаем, что число простое
    for (unsigned p = 2; p*p < N; ++p)
        if(0 == N%p) {
            isp = false; //раз N делится на p, то оно составное
            break; //далее проверять делимость смысла нет, число уже составное
        }
    return isp;
}

/**
 * Вместо создания временного значения isp можно 
 * сразу при обнаружении делителя вернуть false 
 * в качестве результата.
 */
bool is_prime_variation(unsigned N) {
    for (unsigned p=2; p*p < N; ++p)
        if(0 == N%p) return false; //если делитель обнаружен, сразу прерываем функцию и возвращаем false
    return true; //если ни одного делителя не обнаружено, то число простое
}

/**
 * В случае, если функция ничего не возвращает, 
 * то можно прервать её работу с помощью return 
 * без выражения. Рассмотрим задачу: напечатать 
 * число, если оно чётное.
 */
void print_even(unsigned N) {
    if (N%2) return; //если число нечётное, то ничего не делаем, покидаем функцию
    printf("%d\n",N); //чётное число печатаем
}

/**
 * Не стоит злоупотреблять такой возможностью!
 * Если в функции будет много "точек выхода", 
 * то анализ ошибок в такой функции может оказаться 
 * крайне затруднительным!
 */

/**
 * Рассмотрим вопрос о передаче массива в функцию.
 * При работе с массивами мы очень часто совершаем 
 * одни и те же действия, например, печать массива.
 * Хотелось бы вынести эти действия в функцию, чтобы 
 * можно было просто писать print_arr(numbers).
 * Для того, чтобы определить массив параметром функции 
 * можно использовать один из трёх способов.
 */
/**
 * Точно указать тип элементов и их количество.
 */
void print_int_arr10(int arr[10]) { //объявление параметра добавляет переменную в блок функции, в данном случае массив из 10 элементов
    for (unsigned idx = 0; idx != 10; ++idx)
        printf("%d ",arr[idx]);
    printf("\n");
}
/**
 * Такая функция сможет принимать массивы из 10 элементов.
 * Многие компиляторы будут предупреждать о том, что число 
 * элементов не совпадает, однако код по прежнему будет 
 * выполняться. Если в такую функцию передать массив с большим 
 * количеством элементов, то ничего страшного не произойдёт, 
 * просто напечатается часть элементов. Но если массив содержит 
 * меньше элементов, то возникнет Undefined behavior (UB), 
 * неопределённое поведение, вызванное выходом за пределы 
 * массива. Кроме того, в функцию с таким параметром не получится 
 * передать массив, размещённый в динамической памяти.
 */

/**
 * Во многих случаях более выгодным является не указывать 
 * длину массива в описании параметра массива, а передать 
 * длину вторым параметром.
 * Обратим внимание на то, что зная только имя массива нет 
 * возможности узнать его размер, количество элементов!
 * Необходимо так или иначе передавать его в функцию, 
 * либо указав в описании параметра-массива, либо во 
 * втором параметре!
 */
void print_int_arr(int arr[], unsigned size) {
    for (unsigned idx = 0; idx != size; ++idx)
        printf("%d ",arr[idx]);
    printf("\n");
}

/**
 * Третий способ - поставить в качестве формального параметра 
 * указатель, адрес. При этом код функции никак не изменится.
 * Этим способом мы будем часто пользоваться в будущем.
 */
void print_int_arr_ptr(int *arr, unsigned size) {
    for (unsigned idx = 0; idx != size; ++idx)
        printf("%d ",arr[idx]);
    printf("\n");
}

/**
 * При передаче массива в функцию, следует учитывать, что 
 * работа с массивом несколько отличается от работы с 
 * другими переменными. Если обычные переменные копируются 
 * в функцию, то массивы передаются косвенно, т.к. функция 
 * может не только прочитать данные массива, но и изменить 
 * их!
 */
void arr_int_double(int arr[], unsigned size) {
    for (unsigned idx = 0; idx != size; ++idx)
        arr[idx] *= 2; //мутирующая арифметика перезаписывает данные массива
}

/**
 * Функции, которые помимо генерации результата совершают 
 * действия, связанные с косвенным изменением данных, 
 * называются "функции с побочным эффектом". Например, все 
 * функции печати - это функции с побочным эффектом, т.к. 
 * они косвенно меняют данные буфера вывода.
 * С побочными эффектами следует быть осторожным!
 * Так как функция может менять данные массива косвенно, 
 * то передать в функцию массив неизменяемых, константных 
 * значений описанными выше способами нельзя. Нужно указать 
 * в параметре, что массив ожидается именно с константными 
 * данными.
 */
void print_int_arr_const(int const arr[], unsigned size) {
    for (unsigned idx = 0; idx != size; ++idx)
        printf("%d ",arr[idx]);
    printf("\n");
}

/**
 * Иногда наличие побочных эффектов очень удобно!
 * Например при сортировке.
 * Или при перестановке элементов между собой.
 */
void arr_swap_elements(int arr[], unsigned idx1, unsigned idx2) {
    int tmp = arr[idx1];
    arr[idx1] = arr[idx2];
    arr[idx2] = tmp;
}

int main() {
    if (false) 
    {
        int a = 1.f, b = 2.f, c = 3.f;
        printf("area is %f\n",triangle_area(a,b,c));
        printf("area is %f\n",triangle_area_variation(a,b,c));
    }

    if(false)
    {
        unsigned N = 7179;
        printf("%u %s prime\n",N,is_prime(N)?"is":"is not");
        printf("%u %s prime\n",N,is_prime_variation(N)?"is":"is not");
    }

    if (false)
    {
        int arr[10] = {1,2,3,4,5,6,7,8,9,0};
        print_int_arr10(arr); //мы указываем только имя массива, никаких дополнительных значков
        print_int_arr(arr,10); //в параметр массива передаём имя массива, вторым параметром передём размер
        print_int_arr_ptr(arr,10); //если в качестве формального параметра в функции стоит указатель, то вызов не меняется - передаём имя массива
    }

    //вызов функции, косвенно меняющей данные
    if (false)
    {
        int arr[10] = {1,2,3,4,5,6,7,8,9,0};
        print_int_arr(arr,10); //массив до вызова функции arr_int_double
        arr_int_double(arr,10);
        print_int_arr(arr,10); //массив после вызова функции arr_int_double
    }

    if (false) 
    {
        int const arr[10] = {1,2,3,4,5,6,7,8,9,0};
        //print_int_arr(arr,10);//ошибка компиляции! массив неизменяемых данных передаётся в функцию, которая не даёт гарантий неизменяемости
        print_int_arr_const(arr,10);//всё правильно, функция ожидает массив неизменяемых данных и не сможет поменять данные в массиве
    }

    return 0;
}


