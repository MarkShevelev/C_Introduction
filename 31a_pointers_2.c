/**
 * В данном файле приведены примеры кодов, использующих 
 * указатели на константы и неизменяемые указатели. 
 * Также рассматривается вопрос "множественной косвенности".
 */

#include <stdio.h>
#include <stdbool.h>

int main() {
    /**
     * Указатели позволяют менять данные путём применения 
     * операции деструктивного присваивания после разыменования.
     * Однако для констант операция присваивания запрещена!
     * Это накладвает определённые ограничения на указатели.
     */
    if (false)
    {
        //объявляем и инициализируем константу, помните, константу нельзя оставлять неинициализированной, т.к. последующее присваивание невозможно
        int const i_cv = 5; //неизменяемое поименованное значение
        int *int_ptr; //обычный указатель на число типа int
        //int_ptr = &i_cv;//предупреждение/ошибка: assignment discard 'const' qualifier
        //для того, чтобы можно было сохранить адрес на поименованную константу необходим специальный тип указателя
        int const *int_cv_ptr; //это "указатель на константу"
        //указателю на константу можно присвоить адрес как константы, так и неконстантного значения
        int_cv_ptr = &i_cv;
        //затем это значение константы можно прочитать посредством разыменования
        printf("dereference constant value: %d\n", *int_cv_ptr);
        //присваивание запрещено (!), чтобы случайно не повредить константу, помните, изменение константы приводит к неопределённому поведению
        //*int_cv_ptr = 7; //ошибка/предупреждение: assignment of read-only location
        
        int i_var = 7; //это изменяемое значение
        int_cv_ptr = &i_var; //без проблем можно сохранить адрес изменяемого значения в указатель на константу
        //*int_cv_ptr = 5; //но изменить значение посредством указателя по-прежнему нельзя: assignment of read-only location
        printf("dereference pointer to variable: %d\n", *int_cv_ptr);
        //семантика самой переменной от этого не меняется, ей можно присваивать новые значение
        i_var = -5;
        printf("dereference pointer to variable: %d\n", *int_cv_ptr);
    }

    /**
     * Указатель может хранить адрес константы, тогда он называется 
     * "указатель на константу". Связанный с указателем тип в этом случае 
     * содержит квалификатор 'const', что не позволяет изменять 
     * значение в связанной памяти посредством разыменования.
     * Бывают ситуации, когда мы вполне согласны с тем, что память по 
     * указанному адресу может быть изменена, но по какой-то причине 
     * не хотим, чтобы менялся адрес, который хранит указатель. 
     * Такой указатель называется "константный указатель" или "неизменяемый 
     * адрес". Для того, чтобы объявить константный указатель необходимо 
     * поставить ключевое слово 'const' между '*' и именем указателя.
     */
    //разница между константным указателем и указателем на константу
    if (false)
    {
        int const i_cv = 5;
        int i_var = -5, j_var = -7;
        int const *i_cv_ptr = &i_cv; //указатель на константу
        int * const i_var_ptr_cv = &i_var; //константный указатель

        //*i_cv_ptr = -5; //операция запрещена, т.к. связанный тип указателя говорит компилятору, что это адрес неизменяемой памяти (!)
        *i_var_ptr_cv = 5; //допустимо! связанный тип не добавляет каких-либо ограничений
        i_cv_ptr = &i_var; //допустимо! можно поменять значение в указателе,т.е. сам указатель теперь хранит другой адрес
        //i_var_ptr_cv = &j_var; //операция запрещена, т.е. указатель i_var_ptr_cv является неизменяемой памятью, хоть и хранит адрес изменяемых данных (!)
    }

    /**
     * Если const стоит у переменной, то он говорит, что сама переменная 
     * не изменяема. Если const стоти слева от звезды, то он говорит, что 
     * неизменяемы данные, которые получаются путём разыменования
     * указателя.
     */

    //множественная косвенность
    if (false)
    {
        int i_var = 5; //переменная типа int
        int *i_ptr = &i_var; //указатель, который хранит адрес переменной типа int
        /**
         * Но сам указатель - это тоже переменная! Переменная для хранения 
         * адреса. Значит каждый указатель тоже имеет определённый адрес
         * в памяти! Этот адрес тоже можно получить с помощью оператора 
         * '&'.
         */
        printf("%p\n",&i_ptr);

        /**
         * Адрес указателя тоже можно сохранить в памяти, но для этого 
         * нам потребуется специальный тип данных - указатель на указатель.
         */
        int * * i_ptr_ptr = &i_ptr;
        printf("%p\n%p\n",i_ptr_ptr,&i_ptr);

        /**
         * Зачем нужен такой сложный тип?
         * Это связано с операцией разыменования.
         * Когда мы разыменовываем обычный указатель int *, то мы получаем 
         * число типа int. Когда же мы разыменовываем указатель на 
         * указатель, то получаем указатель! Т.е. такие данные, которые 
         * снова можно разыменовать. Таким образом к указателю на указатель
         * операция разыменования применима дважды! Об этом нас и 
         * информируют (точнее не нас, а компилятор) две звёздочки.
         */

        //если указатель на указатель разыменовать дважды, то мы получим значение связанного типа
        printf("%d\n",**i_ptr_ptr);

        /**
         * Так как i_ptr_ptr - это тоже переменная, то и у неё есть адрес!
         * Мы можем получить и его. Таким образом мы создаём множественную
         * косвенность для обращения к данным. Уровень этой косвенности
         * ничем не ограничен. Это бывает особенно полезно 
         * при работе с многомерными массивами.
         */
    }

    /**
     * При множественной косвенности усложняется понятие константности.
     * Теперь у нас может быть константным или сам указатель, или 
     * данные по адресу, на которые он указывает, или данные, на которые 
     * указывает указатель, адрес которого мы храним...
     */
    if (false)
    {
        int const i_cv = 5;
        int const *i_cv_ptr = &i_cv;
        int const * * i_cv_ptr_ptr = &i_cv_ptr;

        int i_var = -5;
        int *i_ptr = &i_var;
        int * * i_ptr_ptr = &i_ptr;
        //i_cv_ptr_ptr = i_ptr_ptr; //данная операция отмечается компилятором как небезопасная, т.к. в некоторых случаях она бы могла привести к тому, что неизменяемые данные легально получили бы статус изменяемых

        int * * const i_ptr_ptr_cv = i_ptr_ptr; //данная операция совершенно законна, она не затрагивает константность данных, а относится только к константности самой переменной i_ptr_ptr_cv

        int * const * i_ptr_cv_ptr;
        i_ptr_cv_ptr = i_ptr_ptr; //данная операция позволена, т.к. она запрещает менять данные после первого разыменования
    }

    return 0;
}
