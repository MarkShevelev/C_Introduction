/**
 * В некоторых ситуациях конструкция if () { } else { } оказывается избыточной, 
 * особенно, если главная задача условия - это изменение значения какой-либо переменной.
 * В подобных ситуациях упростить чтение и запись кода можно с помощью тернарного оператора.
 * Для использования тернарного оператора не требуется дополнительных заголовков.
 */

#include <stdio.h>

int main() {
    /**
     * Рассмотрим задачу о нахождении модуля числа.
     * Задана переменная a. В переменную b необходимо сохранить модуль значения a.
     * 
     * Модуль числа равен самому числу, если оно пложительно, и противоположному, если число отрицательно.
     * Это можно выразить явно условной конструкцией.
     */
    int a = -3, b;
    if (a < 0)
        b = -a;
    else
        b = a;
    printf("module %d is %d\n",a,b);

    /**
     * Конструкция содержит больше обслуживающих символов, чем нужного кода.
     * Присваивание повторяется в обеих ветвях.
     * Условное выражение или тернарный оператор позволяют записать это иначе.
     * Тернарный оператор получил название по количеству аргументов. Это единственный 
     * оператор в языке C, который требует трёх аргументов.
     * <условие> ? <условие верно> : <условие неверно>
     * Элементы в угловых скобках - аргументы оператора.
     * В нашем случае <условие> => a < 0, <условие верно> => b = -a, <условие неверно> => b = a
     */
    (a < 0) ? (b = -a) : (b = a);
    printf("module %d is %d\n",a,b);

    /**
     * Важным отличием тернарного оператора от условной конструкции является то, 
     * что оператор - это выражение, которое возвращает значение.
     * Потому мы можем не повторять присваивание дважды!
     * При исполнении тернарный оператор проверяет условие и возвращает одно из двух значений.
     */
    b = a < 0 ? -a : a; //если a < 0, то оператор возвратит -a, результат будут присвоен в b
    printf("module %d is %d\n",a,b);

    /**
     * Ещё один случай, когда тернарный оператор удобен - это вызов функции с разными аргументами 
     * в зависимости от условия. Например нам необходимо напечатать является ли число чётным или 
     * нечётным. Эту задачу можно было бы решить следующим образом.
     */
    int number = 23;
    if (number%2) //не забываем, что условие вычисляет выражение и при ненулевом значении исполняет блок после if
        printf("the number %d is odd\n",number);
    else
        printf("the number %d is even\n",number);
    /**
     * В коде выше много повторяющихся элементов.
     * По существу, мы в обоих случаях обязательно вызываем функцию printf,
     * меняется только одно слово. Было бы удобно вызывать функцию и заменять только 
     * это слово в аргументах.
     */
    printf("the number %d is %s\n", number, number%2 ? "odd" : "even");
    /**
     * Мы воспользовались возможностью выводить в printf строку из параметров.
     * Сама строка выбирается с помощью тернарного оператора.
     */
    
    /**
     * Тернарный оператор обладает более низким приоритетом, чем арифметические операции, 
     * потому нет необходимости брать арифметические операции в скобки.
     * Но тернарный оператор обладает более высоким приоритетом, чем присваивание, 
     * потому скобки вокруг присваивания на строке 35 обязательны!
     */

    /**
     * Как и любой оператор, тернарные операторы могут комбинироваться путём вставки одних операторов 
     * в аргументы других. Перепишем вычисление високосного года через тернарный оператор.
     */
    int year = 1900;
    printf("the year %d is %s\n", year,
        year%4 ? "not leap" : (
            year%100 ? "leap" : (
                year%400 ? "not leap" : "leap"
            )
        )
    ); //для удобства вложенные тернарные операторы выделенны смещением
    //printf("the year %d is %s\n", year, year%4 ? "not leap" : (year%100 ? "leap" : (year%400 ? "not leap" : "leap")));

    /**
     * Тернарный оператор может помочь в инициализации констант.
     * Так как значения констант нельзя поменять после их объявления, то 
     * код на строках 19-22 не применим в том случае, когда b - констранта.
     */
    int const a_cv = -3, b_cv = a_cv < 0 ? -a_cv : a_cv;

    /**
     * Так как тернарный оператор возвращает значение, как и любое выражение, 
     * он должен получить тип, для последующих проверок типизации.
     * Потому ветви верного и неверного условия должны иметь приводимый к общему тип.
     * Иначе мы получим ошибку компиляции.
     */
    //a < 0 ? "Hello" : 1.2f; //данный код не будет компилироваться

    return 0;
}