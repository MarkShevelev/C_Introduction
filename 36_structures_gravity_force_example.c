/**
 * Задача. Набор гравитирующих масс.
 * Точечная масса на плоскости характеризиуется
 * парой координат в ортогональном базисе.
 * Сила гравитации - вектор, направленный от 
 * одной массы к другой вдоль линии, их соединяющей.
 * Модуль силы: F = m1 * m2 / (r * r) (1), где
 * mi - массы, r - расстояние между точками.
 * Используя инструмент структур языка C, 
 * напишите программу, которая рассчитывает 
 * равнодействующую силу на пробную точечную 
 * массу со стороны набора других масс.
 */

#include <stdio.h>
#include <math.h>

typedef //для упрощения написания кода применим переименование 
struct _Body {
    float x, y, m; //характеристики точечной массы, выраженные структурой
} Body_t; //новое имя для типа struct _Body - это Body_t, теперь struct _Body и Body_t используются равноправно

typedef
struct _Force {
    float fx, fy; //сила представлена своими компонентами в базисе
} Force_t; //переименование для struct _Force действует аналогично

/**
 * Не забывайте комментировать код!
 * Функция вычисляет гравитационную силу по 
 * формуле (1) со стороны тела src (source, источник)
 * на тело dst (destination, место назначения).
 */
Force_t gravity_force(Body_t dst, Body_t src) {
    float r2 = (dst.x - src.x) * (dst.x - src.x) + (dst.y - src.y) * (dst.y - src.y);
    float F_value = dst.m * src.m / r2;
    //покомпонентно записываем силу в список для инициализации структуры Force_t
    return (Force_t){F_value * (src.x - dst.x) / sqrt(r2), F_value * (src.y - dst.y) / sqrt(r2) };
}

/**
 * Функция покомпонентного сложения сил.
 */
Force_t force_sum(Force_t f1, Force_t f2) {
    return (Force_t){f1.fx + f2.fx, f1.fy + f2.fy};
}

/**
 * Вычисление равнодействующей силы со 
 * стороны роя *src в количестве тел size 
 * на пробное тело dst.
 */
Force_t resultant_gravity_force(Body_t dst, Body_t *src, unsigned size) {
    //равнодействующая - это покомпонентная сумма всех сил
    Force_t res = {0.f, 0.f};
    for (unsigned idx = 0; idx != size; ++idx)
        res = force_sum(res, gravity_force(dst,src[idx] ));
    return res;
}

/**
 * Обратите внимание. Благодаря тому, что мы 
 * заранее написали функции для работы со 
 * структурами, при вычислении равнодействующей 
 * силы нам не пришлось производить декомпозицию 
 * структур! Программу можно улучшить, если 
 * создать отдельный тип векторов и дополнить 
 * его сложением, вычитанием, умножением на число и 
 * скалярным произведением. Затем переиспользовать 
 * при работе с силой и телами.
 * Оставим это в качестве упражнения.
 */

void print_force(Force_t f) {
    printf("(%f,%f)",f.fx,f.fy);
}

//пример вызова функции вычисления равнодейтсвующей
int main() {
    Body_t swamp[3] = { {-1.f, -0.5f, 1.f}, {1.f, -0.5, 1.f}, {0.f,1.f,0.9f} };
    Body_t probe = {0.f, 0.f, 1.f};
    print_force( resultant_gravity_force(probe,swamp,3) );

    return 0;
}


