/**
 * Цикл while покрывает полностью потребности языка в части 
 * теоремы Бёма-Якопини, т.е. наличие цикла while и условий if () { } else { } 
 * достаточно, чтобы реализовать любой алгоритм. Однако удобство 
 * написания и чтения кода тоже важно.
 * Конструция цикла for позволяет делать тоже самое, что и конструкция while,
 * но в некоторых случаях оказывается более удобной.
 */

#include <stdio.h>
#include <stdbool.h>
#include <float.h>

int main() {
    /**
     * Цикл for - это цикл с предусловием, который позволяет многократно исполнять 
     * один и тот же блок кода. При этом в объявлении цикла присутствуют три важных 
     * элемента цикла: инициализация, условие, вариант (продвижение).
     * Рассмотрим задачу о печати заданного числа фраз Hello!
     */
    if (false) 
    {
        /**
         * Общий вид синтаксиса цикла for
         * for ( <инициализация> ; <условие> ; <продвижение> )
         * <инициализация> - утверждение (statement), которое выполняется один раз до начала работы цикла
         * <условие> - проверяется перед каждой итерацией, если верно, то итерация исполняется
         * <продвижение> - выражение, которое исполняется в конце каждой итерации
         */
        int counter;
        for (counter = 0; 10 != counter; ++counter) //обратите внимание, что мы выполняем увеличение счётчика в заголовке цикла
            printf("%d Hello!\n");         
        //выражение продвижения выполняется строго после итерации!
    }

    /**
     * Цикл for позволяет в части инициализации определять переменные, 
     * которые будут доступны только внутри цикла.
     * Благодаря чему можно легко определять циклы с одинаковыми именами счётчиков, индексов и 
     * других вспомогательных переменных.
     */
    //реализуем задачу о числах Фибоначчи, используя цикл for
    if (false)
    {
        unsigned long long fN = 1, fNm1 = 1; unsigned max_count = 23;
        for (unsigned counter = 1; max_count != counter; ++counter) { //вспомогательная переменная counter видна только внутри цикла
            unsigned long long next = fN + fNm1;
            fNm1 = fN;
            fN = next;
        }
        printf("F(%u) = %llu\n",max_count,fN);
    }

    /**
     * Любой из трёх элементов цикла for можно опустить.
     * Если опустить инициализацию, то никаких дополнительных действий до начала цикла совершаться не будет.
     * Если опустить условие, то оно будет считаться истинным.
     * Если опустить продвижение, то никаких дополнительных действий после итерации совершаться не будет.
     * Однако нельзя убрать разделители ;
     * for ( ; ; ) - заголовок бесконечного цикла
     */ 
    //реализуем задачу о нахождении предела рекурентной последовательности с использованием цикла for
    if (false) 
    {
        float aN = 0.25; //очередной член последовательности
        float diff = aN; //разность предыдущего и последующего членов
        for ( ; diff/aN > FLT_EPSILON; ) {
            float next = 0.25 + aN*aN;
            diff = next - aN; 
            aN = next; 
        } 
        printf("lim(N->inf) = %f\n",aN);
    }
    return 0;
}