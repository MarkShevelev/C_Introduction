/**
 * Иногда простые и очевидные решения могут оказаться неверными, 
 * например, приводить серьёзным проблемам с производительностью.
 * Рассмотрим задачу о числах Фибоначчи.
 * Каждое последующее число Фибоначчи равно сумме двух предыдущих.
 * Рекурсивный подход к её решению кажется естественным.
 */

#include <stdio.h>
#include <stdbool.h>

/**
 * Числа Фибоначчи достаточно быстро растут.
 * 50-е число Фибоначчи невозможно сохранить в 
 * типе данных unsigned. Потому будем использовать 
 * тип данных с большими возможностями - unsigned long long.
 */
unsigned long long fibonacci_naive_rec(unsigned N) {
    if (0 == N || 1 == N) return 1; //база рекурсии
    return fibonacci_naive_rec(N-1) + fibonacci_naive_rec(N-2); //шаг рекурсии и рекурсивный вызов
}

/**
 * Если попытаться использовать функцию fibonacci_naive_rec 
 * для рассчёта чисел больше 50, то время расчёта будет 
 * катастрофическим. Если внимательно посмотреть на код, 
 * то становится ясно, что многие числа расчитываются 
 * повторно, многократно. Количество действий, которые 
 * необходимо произвести для расчётов N-го числа, растёт 
 * экспоненциально! Этого можно избежать, если 
 * все уже подсчитанные значения чисел Фибоначчи будут 
 * сохранены. Такой подход называется "динамическим программированием".
 */
//функция получает в качестве дополнительного параметра массив, в который записаны рассчитанные числа 
unsigned long long fibonacci_dynamic_rec(unsigned N, unsigned long long fib[]) {
    //если число уже было рассчитано, то оно больше нуля, иначе рассчитаем это число
    unsigned long long fibNm2 = fib[N-1] > 0 ? fib[N-1] : fibonacci_dynamic_rec(N-1,fib);
    /**
     * На самом деле, данный расчёт уже не является необходимым, т.к. 
     * при расчёте N-1 числа Фибоначчи было рассчитано и N-2.
     * Алгоритм из экспоненциального стал линейным!
     */
    unsigned long long fibNm1 = fib[N-2] > 0 ? fib[N-2] : fibonacci_dynamic_rec(N-2,fib);

    //сохраняем в массиве новое рассчитанное число
    fib[N] = fibNm2 + fibNm1;
    return fibNm2 + fibNm1;
}

/**
 * Если наша цель состоит только в том, чтобы рассчитать N-е число 
 * Фибоначчи, то нет необходимости сохранять целый массив. Можно 
 * ограничиться двумя предыдущими числами Фибоначчи. Их можно 
 * передавать при вызове функции в качестве аргументов.
 */
//два новых параметра необходимы для передачи двух предыдущих чисел Фибоначчи
unsigned long long fibonacci_tail_rec(unsigned N, unsigned long long fNm1, unsigned long long fNm2) {
    /**
     * Так же, как и в задаче о возведении в степень, мы используем входящий параметр
     * fNm1 в качестве аккумулятора, т.е. мы накапливаем сумму в fNm1.
     * Если далее рассчитывать нечего, то просто возвращаем аккумулятор.
     * Это база рекурсии.
     */ 
    if (1 == N || 0 == N) return fNm1;

    /**
     * Если расчёт ещё не окончен, то мы в качестве нового значения 
     * аккумулятора передаём сумму предыдущих значений, а в качестве 
     * числа F(N-2) передаём предыдущее значение аккумулятора.
     * fNm2 -> fNm1; fNm1 -> fNm1 + fNm2
     */
    return fibonacci_tail_rec(N-1,fNm1+fNm2,fNm1);
}
/**
 * Приведённый выше алгоритм - это хвостовая рекурсия. Он 
 * легко может быть оптимизирован в цикл.
 */
unsigned long long fibonacci_loop(unsigned N) {
    unsigned long long fNm1 = 1, fNm2 = 1;
    for (; 1 != N && 0 != N; --N) {
        unsigned long long tmp = fNm1 + fNm2;
        fNm2 = fNm1;
        fNm1 = tmp;
    }
    return fNm1;
}

int main() {
    //использование наивного подхода к решению задачи о числах Фибоначчи
    if (false)
    {
        //если мы рассчитываем относительно небольшое число, то это происходит быстро
        printf("F(10) = %llu\n",fibonacci_naive_rec(10));

        //если мы рассчитываем достаточно большое число, то задержки во времени велики
        printf("F(48) = %llu\n",fibonacci_naive_rec(48));
    }

    /**
     * Использование динамического программирования для ускорения
     * расчёта чисел Фибоначчи.
     */
    if (false)
    {
        unsigned long long fib[51]; //массив для хранения уже рассчитанных чисел
        for (unsigned idx = 0; idx != 51; ++idx)
            fib[idx] = 0llu; //изначально все числа равны нулю, т.е. ещё не рассчитанны
        fib[0] = 1llu;
        fib[1] = 1llu; //начальные значения, база рекурсии

        //число рассчитывается значительно быстрее в сравнении с наивным алгоритмом
        printf("F(50) = %llu\n",fibonacci_dynamic_rec(50,fib));
    }

    /**
     * Использование хвостовой рекурсии и итерационного алгоритма
     */
    if (false) 
    {
        printf("F(50) = %llu\n",fibonacci_tail_rec(50,1llu,1llu));
        printf("F(50) = %llu\n",fibonacci_loop(50));
    }

    return 0;
}

