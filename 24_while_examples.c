/**
 * Примеры простых алгоритмов, записанных с помощью цикла while
 */

#include <stdio.h>
#include <stdbool.h>
#include <float.h>
#include <math.h> //математические функции: fabsf - модуль числа float, sqrtf - корень квадратный числа float

int main() {
    /**
     * Алгоритм Евклида нахождения наибольшего общего делителя НОД
     */
    if (false)  //для работы блока кода замените условие на true или 1
    {
        int x = 76, y = 8, gcd;
        {
            int a = x, b = y;
            while (b != 0) { //не хотелось бы делить на ноль =)
                int r = a%b;
                a = b;
                b = r;
            }
            gcd = a;
        }
        printf("GCD (%d,%d) = %d\n",x,y,gcd);
    }

    /**
     * Вычисление чисел Фибоначчи.
     * Каждое последующее число Фибоначчи выражается суммой двух предыдущих.
     * F(N+1) = F(N) + F(N-1)
     * Зная первые два числа F(0) = 1 и F(1) = 1, можно вычислить любое число 
     * Фибоначчи, многократно повторяя сложение.
     */
    if (false) 
    {
        unsigned long long fN = 1, fNm1 = 1; //начальные значения чисел F(N) и F(N-1)
        unsigned counter = 1; //счётчик повторений, по счётчику мы определяем какое по номеру число подсчитано
        unsigned const max_number = 23;
        while (max_number != counter) { //пока мы не досчитали до нужного номера, продолжаем
            unsigned long long next = fN + fNm1;
            ++counter;
            fNm1 = fN; //сдвигаем значения чисел вперёд, то число, которое было N-1 имеет значение F(N)
            fN = next; //а F(N) теперь имеет значение F(N+1)
        }
        printf("F(%llu) = %llu\n",max_number,fN);//не забываем, что для вывода чисел unsigned long long нужен специальный местозаместитель %llu
    }

    /**
     * Если есть сложная последовательность, для которой известно существование предела, 
     * но его точное значение не удаётся найти, то можно сделать это численно, 
     * т.е. приближённо получить значение. Если x(N) задано явно: x(N) = 1/N, 
     * то можно попытаться просто подставить очень большое N.
     * Однако это не всегда удобно или возможно, бывает выгоднее выразить последующий член через предыдущий.
     * Рассмотрим рекурентно заданную последовательность:
     * x(N+1) = 0.25 + x(N)*x(N) и x(0) = 0.25.
     * Очевидно, что данная последовательность ограничена сверху 1, 
     * её возрастание можно доказать методом индукции.
     * У данной последовательности есть предел, мы можем найти его приблизительно.
     */
    if (false)
    {
        float aN = 0.25; //очередной член последовательности, инициализируем первым значением - x(0)
        float diff; //разность предыдущего и последующего членов, если она мала, то мы близки к пределу
        do {
            float next = 0.25 + aN*aN;
            diff = next - aN; //последовательность возрастающая, потому мы из последующего вычетаем предыдущий
            aN = next; //заменяем текущий на последующий
        } while (diff/aN > FLT_EPSILON); //diff обязательно нужно объявлить вне блока цикла! иначе его нельзя будет использовать в условии
        printf("lim(N->inf) = %f\n",aN);
        /**
         * Обратите внимание на сравнение в условии цикла.
         * Если сравнивать разность diff > eps, то точное значение eps сложно подобрать, т.к. 
         * числа с плавоющей точкой не всюду имеют одинаковую минимальную разность, т.е. нет абсолютной точности.
         * Последовательность сходится => элементы последовательности близки друг к другу и к aN.
         * Тогда максимально возможную точность можно оценить как FLT_EPSILON*aN.
         * diff > FLT_EPSILON*aN => diff/aN > FLT_EPSILON.
         */

        //пример бесконечно малой последовательности
        aN = 0.25;
        do {
            float next = aN*aN;
            diff = aN - next;
            aN = next;
        } while (diff/aN > FLT_EPSILON);
        printf("lim(N->inf) = %f\n",aN);

        //пример немонотонной сходящейся последовательности a(N+1) = (a(N) - 2*a(N-1))/3
        aN = 0.5; float aNm1 = 0.5; unsigned n = 1; //aNm1 - это чле последовательности a(N-1)
        do {
            float next = (aN - 2*aNm1)/3.f; //данная последовательность задана таким образом, что зависит от двух предыдущих элементов
            diff = next - aN; //разность двух соседних членов
            aNm1 = aN;
            aN = next;
        } while (fabsf(diff/aN) > FLT_EPSILON); //так как последовательность немонотонна, а aN знакопеременный, то мы берём модуль при сравнении 
        printf("lim(N->inf) = %f\n",aN);
    }

    /**
     * Повторяющиеся конструкции можно использовать для приближённого нахождения 
     * значений функций. Например, если известна сама функция и она монотонна, то 
     * известно, что у неё есть обратная. Однако выразить значение обратной функции 
     * явно может быть затруднительно.
     * Рассмотрим функцию возведения в квадрат и обратную к ней. Умея только возводить 
     * в квадрат можно написать последовательную процедуру вычисления корня.
     */
    //вычисляем корень из 2
    if (false) 
    {
        float left = 1.f, right = 2.f; //мы знаем, что корень из 2 находится между 1 и 2
        float guess = (left+right)*0.5f, sqr_guess = guess*guess; //вероятно, верный ответ посередине...

        while (fabsf(sqr_guess - 2.f)/2.f > FLT_EPSILON) { //пока мы далеко от корня (здесь мы говорим не о разности соседних, а о близости к нужному числу)
            if (sqr_guess > 2.f ) right = guess; else left = guess; 
            guess = (left+right)*0.5f;
            sqr_guess = guess*guess;
        }
        //посмотрим, совпадает ли наш результат с результатом работы стандартной функции корня квадратного
        printf("%f %f\n",guess,sqrtf(2.f));
    }
    /**
     * Привидённый выше метод работает для любой монотонной функции.
     * Он носит название метод дихотомии. Последовательное деление 
     * попалам участка локализации корня уравнения. В нашем примере 
     * происходило вычисление корня уравнения x*x - 2 = 0;
     */

    return 0;
}