/**
 * Функции можно вызывать не только из основного кода в main, 
 * но и из любых других функций. Особенно интересным является 
 * возможность вызывать внутри функции саму себя. Такую 
 * организацию кода называют "рекурсивным вызовом". Использование 
 * рекурсивных вызовов позволяет нам писать программы без 
 * использования циклов, но с повторяющимися действиями.
 * По существу, рекурсивный вызов - это альтернатива циклам и 
 * итерациям для создания многократно повторяющегося кода.
 */

#include <stdio.h>
#include <stdbool.h>

/**
 * Рассмотрим задачу о печати слова Hello любое заданное 
 * число раз. Для её решения ранее мы использовали цикл.
 * Попытаемся решить её только инструментами функций!
 */

//легко написать функцию, которая печатает Hello один раз
void print_hello() {
    printf("Hello\n");
}

/**
 * Чтобы напечатать Hello неограниченное число раз, 
 * можно составить несложный код.
 * Достаточно, чтобы после печати слова Hello функция 
 * вызывала себя же!
 */
//бесконечная печать Hello
void print_hello_inf() {
    printf("Hello\n");
    print_hello_inf();//напечатаем ещё разок... 
}

/**
 * Если внимательно рассмотреть вопрос о том, как 
 * работает функция print_hello_inf на уровне 
 * исполнения микропроцессором, то мы увидим, что 
 * при каждом вызове функции print_hello_inf перед 
 * её завершением происходит переход по коду в начало 
 * функции, словно бы это происходило в цикле! Но в 
 * отличие от цикла, при вызове функции необходимо 
 * запомнить точку, откуда шёл вызов, чтобы вернуться 
 * в вызывающий код. А ещё необходимо запомнить состояние 
 * всех регистров процессора и т.п. На это выделяется 
 * специальное место на стеке, сохранённые данные называют 
 * "стековый фрейм". К сожалению на каждый вызов функции 
 * необходимо создать стековый фрейм. Следовательно, 
 * каждый новый вызов функции требует дополнительной памяти,
 * в отличие от цикла. Компилятор может определить, что 
 * в стековом фрейме нет необходимости, т.к. никакие данные 
 * не используются полсе рекурсивного вызова и создать 
 * цикл вместо явных вызовов. Это называют "оптимизацией 
 * хвостовой рекурсии". В случае функции print_hello_inf 
 * такая оптимизация возможна, но не гарантирована!
 * Программа может работать бесконечно, а может и 
 * прерваться с сообщением об ошибке памяти.
 */

/**
 * Мы понимаем, как работает функция, печатающее Hello 
 * бескоенчно. Необходимо понять, как этот процесс 
 * остановить. Понятно, что необходимо условие, 
 * которое позволит пропустить код с рекурсивным вызовом.
 * Для этого нам потребуется добавить один параметр в 
 * список - количество раз, которые мы хотим печатать. 
 * Если это кличество равно нулю, то и печатать не нужно!
 */
void print_hello_count(int count) {
    if (0 == count) return;     //напечать ноль раз - ничего не делать - просто выходим
    printf("Hello\n");          //печатем один раз и 
    print_hello_count(count-1); //остаётся напечатать на один раз меньше!
}

/**
 * Решение задач с помощью рекурсии - это сведение 
 * задачи к такой же, но меньшего размера. 
 * Например известная нам функция возведения числа 
 * в целую положительную степень может быть решена 
 * посредством рекурсивного вызова.
 */
float powN_rec(float x, unsigned N) {
    if (0 == N) return 1.f; //возвести в нулевую степень легко
    return x*powN_rec(x,N-1); //если степень не нулевая, тогда нужно возвести в степень на единицу меньше и потом домножить на основание
}

/**
 * В рекурсивных алгоритмах всегда должны присутствовать 
 * три элемента:
 * 1 - шаг рекурсии, композиция решения из решения задачи меньшего размера в решение задачи большего размера
 * 2 - рекурсивный вызов, запрос решения задачи меньшего размера
 * 3 - база рекурсии, тривиальный случай, который разбирается отдельно и не влечёт рекурсивного вызова
 */

/**
 * Если результат работы функции можно точно представить 
 * последним рекурсивным вызовом, то такая рекурсия называется 
 * хвостовой. Например, функция powN_rec - не является функцией 
 * с хвостовой рекурсией, т.к. последняя выполняемая операция - 
 * это умножение. Преобразуем рекурсию в хвостовую, добавит 
 * дополнительный параметр, который будет накапливать результат.
 */
float powN_rec_tail(float base, float accum, unsigned N) {
    if (0 == N) return accum; //дошли до конца - вернули накопленный результат
    return powN_rec_tail(base,accum*base,N-1); //иначе перемножаем накопленный в аккумуляторе результат на основание и уменьшаем степень!
}

/**
 * Функция powN_rec_tail представлена хвостовой рекурсией!
 * Хвостовая рекурсия может быть оптимизирована в цикл,
 * что позволит программе работать быстрее и потреблять 
 * меньше памяти.
 * Вызов функции powN_rec_tail неудобен, так как требует 
 * указать значение параметра accum, который должен принимать 
 * значение 1 при первоначальном вызове.
 * Для удобства можно написать промежуточную функцию.
 */

float powN_rec_tail_aid(float base, unsigned N) {
    return powN_rec_tail(base,1.f,N);
}


int main() {
    if (false)
    {
        int countA = 3; //печатем три раза
        print_hello_count(countA);

        int countB = 10; //печатаем десять раз
        print_hello_count(countB);
    }

    if (false)
    {
        float base = 2.f;
        unsigned N = 10;
        printf("%f^%u = %f\n",base,N,powN_rec(base,N)); //простая рекурсивная форма

        printf("%f^%u = %f\n",base,N,powN_rec_tail(base,1.f,N)); //вызов функции с хвостовой рекурсией

        printf("%f^%u = %f\n",base,N,powN_rec_tail_aid(base,N)); //вызов вспомогательной функции
    }

    return 0;
}
