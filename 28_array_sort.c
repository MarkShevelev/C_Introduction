/**
 * Так как бинарный поиск работает только на упорядоченных, отсортированных данных, 
 * то крайне важно уметь приводить произвольный массив к упорядоченному виду.
 * Алгоритмы, которые выполняют эту задачу, называются "алгоритмами сортировки".
 * Рассмотрим несколько простых алгоритмов с асимптотической сложностью O(N^2).
 */

#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>

int main() {
    /**
     * Один из наиболее очевидных способов отсортировать массив - это 
     * прямой поиск максимального / минимального элемента, перемещение его 
     * на нужную позицию, а затем повторение операции, но для меньшего кол-ва 
     * элементов. Такой алгоритм называется сортировка "прямым выбором".
     */
    if (false) 
    {
        {
            int arr[10];
            srand((unsigned)time(NULL)); //зерно генерации 
            for (unsigned idx = 0; idx != 10; ++idx)
                arr[idx] = rand()%101 - 50; //заполняем массив случайными числами от -50 до 50

            printf("Random value array:\n");
            for (unsigned idx = 0; idx != 10; ++idx)
                printf("%d ",arr[idx]);
            printf("\n");

            
            for (unsigned max_pos = 9; max_pos != 0; --max_pos) { //max_pos необходим для перебора позиций, в которые мы будем записывать максимальный элемент
                unsigned max_idx = 0; //на каждой итерации мы будем вычислять индекс элемента с максимальным значением и перемещать его к правому краю    
                for (unsigned idx = 0; idx != max_pos+1; ++idx)
                    max_idx = arr[idx] > arr[max_idx] ? idx : max_idx;
                //переставляем элементы с номероми max_idx и max_pos, чтобы элемент с максимальным значением оказался с правого края
                int tmp = arr[max_idx];
                arr[max_idx] = arr[max_pos];
                arr[max_pos] = tmp;
            }

            printf("Sorted array:\n");
            for (unsigned idx = 0; idx != 10; ++idx)
                printf("%d ",arr[idx]);
            printf("\n");
        }
    }

    /**
     * Другой простой способ отсортировать массив - это переставлять 
     * неверно упорядоченные пары, пока массив не станет полностью 
     * упорядочен.
     */
    if (false) 
    {
        int arr[10];
        srand((unsigned)time(NULL)); //зерно генерации 
        for (unsigned idx = 0; idx != 10; ++idx)
            arr[idx] = rand()%101 - 50; //заполняем массив случайными числами от -50 до 50

        printf("Random value array:\n");
        for (unsigned idx = 0; idx != 10; ++idx)
            printf("%d ",arr[idx]);
        printf("\n");

        bool sorted; //переменная-флаг, указывающая на отсортированность массива: true - отсортирован, false - не отсортирован
        do {
            sorted = true; //в начале итерации мы предполагаем, что массив уже отсортирован, если это так, то переменная sorted сохранит своё значение
            for (unsigned idx = 0; idx != 9; ++idx)
                if (arr[idx] > arr[idx+1]) { //если элементы идут в неверном порядке, поменяем их
                    int tmp = arr[idx];
                    arr[idx] = arr[idx+1];
                    arr[idx+1] = tmp;
                    sorted = false; //если нам пришлось менять элементы, значит массив не отсортирован
                }
        } while (!sorted);

        printf("Sorted array:\n");
        for (unsigned idx = 0; idx != 10; ++idx)
            printf("%d ",arr[idx]);
        printf("\n");
    }
    /**
     * Описанная выше сортировка устроена таким образом, что 
     * на каждой итерации цикла do while максимальный элемент
     * вытесняется к правому краю, словно пузырёк, "всплывая"
     * через элементы массива. Потому эта сортировка называется 
     * "пузырьковая сортировка".
     */

    /**
     * Ещё один лёгкий способ отсортировать массив с асимптотической 
     * сложностью O(N^2) - это сортировка вставками. В ней массив 
     * делится на две части: отсортированную справа и неотсортированную слева.
     * Изначально правая часть состоит из одного крайнего элемента, т.к. 
     * один элемент всегда отсортирован, а левая - весь остальной массив.
     * На каждом шаге граничный элемент неотсортированной части продвигается 
     * по отсортированной, пока не достигнет того элемента, который больше 
     * продвигаемого. Сортировка завершается, когда граница отсортированной 
     * части достигает начала массива.
     */
    if (false)
    {
        int arr[10];
        srand((unsigned)time(NULL)); //зерно генерации 
        for (unsigned idx = 0; idx != 10; ++idx)
            arr[idx] = rand()%101 - 50; //заполняем массив случайными числами от -50 до 50

        printf("Random value array:\n");
        for (unsigned idx = 0; idx != 10; ++idx)
            printf("%d ",arr[idx]);
        printf("\n");

        for (unsigned left = 9; left != 0; --left) //left - индекс самого левого отсортированного элемента
            for (unsigned idx = left-1; idx != 9 && arr[idx] > arr[idx+1]; ++idx) { //порядок условий важен !!! сначала мы должны убедиться, что индекс допустим, только затем читать элементы массива
                int tmp = arr[idx];
                arr[idx] = arr[idx+1];
                arr[idx+1] = tmp;
            }

        printf("Sorted array:\n");
        for (unsigned idx = 0; idx != 10; ++idx)
            printf("%d ",arr[idx]);
        printf("\n");
    }

    return 0;
}