/**
 * Каждая отдельная переменная при моделировании 
 * объектов реального мира или математического 
 * описания в программе представляет какое-то 
 * отдельное свойство: координату, скорость 
 * или массу. Если у нас много элементов, 
 * описывающих одно и то же свойство для различных 
 * объектов, то мы прибегаем к массивам. Однако 
 * во многих ситуациях каждый отдельный объект
 * не описывается только одним свойством. Например, 
 * при моделировании гравитационного взаимодействия 
 * двух тел нам понадобится для каждого из них 
 * указать свою коодинату, скрость и массу.
 * Или при моделировании в программе работы с 
 * рациональными числами нам придётся описывать 
 * отдельно числитель и отдельно знаменатель.
 * В языке C существует специальный инструмент, 
 * позволяющий объединять несколько свойств для 
 * одного предмета в одной переменной - структуры!
 */

#include <stdio.h>
#include <stdbool.h>

/**
 * Рассмторим функцию, которая выполняет сложение 
 * двух рациональных чисел, определённых числетелем 
 * и знаменателем, причём посредством отдельных 
 * переменных.
 */


void rational_sum(int r1_numerator, int r1_denominator, int r2_numerator, int r2_denominator, int *res_numerator, int *res_denominator) {
    /**
     * У функции достаточно сложная сигнатрура.
     * Т.к. каждое число задаётся двумя параметрами, 
     * то всего у функции будет 4 входящих параметра:
     * два числителя и два знаменателя. Результатом 
     * работы функции также будут два числа. Функция 
     * не может возвращать два значения посредством 
     * return через стек. Мы вынуждены добавить ещё
     * два параметра - это адреса по которым мы запишем 
     * результат суммирования.
     */

    *res_numerator = r1_numerator * r2_denominator + r1_denominator * r2_numerator;
    *res_denominator = r1_denominator * r2_denominator;
    //приведение к несократимому виду опущено, его можо выполнить, найдя НОД, например, алгоритмом Евклида
}

/**
 * Как будет выглядеть вызов функции rational_sum?
 */

void rational_sum_test() {
    int q1_n = 1, q1_d = 2;
    int q2_n = 2, q2_d = 3;
    int q3_n, q3_d; //мы должны заранее объявить переменные результата, чтобы можно было перезаписать память, выделенную под эти переменные косвенным образом

    rational_sum(q1_n,q1_d,q2_n,q2_d,&q3_n,&q3_d);
    /**
     * Достаточно грамоздкий вызов.
     * Одно неверное движение и входящие параметры перепутаны.
     * Также важно не забыть, что два последних параметра - 
     * это верные адреса на уже выделенную память. Потому 
     * переменные под результат объявлены до вызова функции.
     */

    printf("1/2 + 2/3 = %d/%d\n",q3_n,q3_d);
}

/**
 * Если бы параметров было бы не два, а четыре?
 * Сложность работы с функциями, которые моделируют
 * объекты с большим количеством параметров быстро 
 * растёт. Подобный код очень скоро окажется 
 * "неподдерживаемым", т.е. вносить в него изменения
 * или переиспользовать будет чрезвычайно трудно!
 * Чтобы решить эту проблему нам нужно как-то 
 * объединить в одной переменной сразу два элемента
 * данных. Мы бы могли организовать для этого массив,
 * но это сработало бы только в ограниченном случае,
 * когда все свойства одного типа. Язык C предлагает
 * более универсальный выход - объявлить новый тип 
 * данных, который будет представлять собой декартово
 * произведение множеств значений других типов! 
 * В приведённом выше примере - пару чисел типа int.
 */

//объявление структуры
struct rational_t {
    int numerator, denominator;
};
/**
 * Ключевое слово struct вводит объявление 
 * нового типа данных. За ним следует название 
 * типа, которое мы будем писать слева от 
 * имени переменной при объявлении.
 * Пара фигурных скобок ограничивает описание 
 * составных частей нового типа данных.
 * Обратите внимание, что объявление завершается 
 * точкой с запятой (';')!
 */

/**
 * Теперь мы можем создавать переменный типа 
 * struct rational_t!
 */

void struct_rational_test() {
    struct rational_t q1; //объявление новой переменной, обратите внимание на слово struct
    struct rational_t q2, q3; //можно объявлять несколько переменных в одной строке

    /**
     * Основная операция, которую можно производить 
     * над структурами - это операция "декомпозиции".
     * Обозначается точкой('.'). Она позволяет по 
     * имени входящего в состав элемента получить 
     * доступ к данным, которые в нём хранятся.
     * Прочесть или перезаписать.
     */
    q1.numerator = 1; q1.denominator = 2; //мы перезаписали данные в структуре q1
    q2.numerator = 2; q2.denominator = 3; 

    //мы можем читать данные из элементов структур и организовывать сложные выражения
    q3.numerator = q1.numerator * q2.denominator + q1.denominator * q2.numerator;
    q3.denominator = q1.denominator * q2.denominator;

    printf("1/2 + 2/3 = %d/%d\n",q3.numerator,q3.denominator);
}

/**
 * Как и любые фундаментальные типы (int, float, char ...),
 * структуры могут быть объявлены неизменяемыми и могут 
 * быть инициализированы (получать значения при объявлении).
 */

void struct_init_test() {
    struct rational_t const q1 = {1,2}; //инициализация по порядку объявления внутренних элементов
    struct rational_t const q2 = {.denominator = 3, .numerator = 2}; //объявление по внутреннему имени
    struct rational_t const q3 = {q1.numerator * q2.denominator + q1.denominator * q2.numerator, q1.denominator * q2.denominator,}; //инициализация может быть и сложным выражением, а завершающая запятая в списке игнорируется

    //q1.numerator = 2; //изменение данных q1 запрещено, т.к. q1 - константа
    //q2.numerator = 3;
    //q3.numeraotr = 5;
    printf("1/2 + 2/3 = %d/%d\n",q3.numerator, q3.denominator);
}

/**
 * Удобство работы со структурами обеспечивается тем, 
 * что переменные типа структуры могут вести себя, 
 * как целое при операциях присваивания или при 
 * передаче в функцию в качестве параметра.
 */

void print_rational(struct rational_t r) {
    printf("%d/%d",r.numerator,r.denominator);
}

void struct_assignment_and_copy_test() {
    struct rational_t q1 = {1,2};
    struct rational_t q2 = {2,3};
    struct rational_t q3;
    q3 = (struct rational_t){q1.numerator * q2.denominator + q1.denominator * q2.numerator, q1.denominator * q2.denominator};
    /**
     * Если мы присваиваем структуре данные, явно указывая
     * их значения в виде пары в фигурных скобках, то 
     * необходимо явно указать для какой именно структуры
     * это происходит.
     */
    struct rational_t q4;
    q4 = q3; //если мы присваиваем значение одной структуры другой структуре, то это просто операция =
    //передача в функцию оказывается очень простой
    print_rational(q1); printf(" + "); print_rational(q2); printf(" = "); print_rational(q4); printf("\n");
} 

/**
 * Основная идея работы со структурами:
 * описать все необходимые действия над 
 * элементами структур в функциях. В 
 * основном же коде использовать только 
 * вызовы этих функций, не обращаясь уже 
 * к операции декомпозиции.
 */

/**
 * Функция возвращает структуру в качестве
 * результата.
 */
struct rational_t struct_rational_sum(struct rational_t q1, struct rational_t q2) {
    struct rational_t res = {q1.numerator * q2.denominator + q1.denominator * q2.numerator, q1.denominator * q2.denominator};
    return res;
    
    /**
     * На самом деле нет необходимости использовать 
     * временную переменную res.
     * Можно просто описать инициализацию, указав
     * в круглых скобках имя типа.
     */
    //return (struct rational_t){q1.numerator * q2.denominator + q1.denominator * q2.numerator, q1.denominator * q2.denominator};
}

void no_decomposition_test() {
    struct rational_t const q1 = {1,2}, q2 = {2,3};
    print_rational(q1); printf(" + "); print_rational(q2); printf(" = "); print_rational(struct_rational_sum(q1,q2)); printf("\n");
    /**
     * В этой функции мы нигде не прибегали к 
     * декомпозиции структур на отдельные элементы.
     */
}

int main() {
    if (false) rational_sum_test();
    if (false) struct_rational_test();
    if (false) struct_init_test();
    if (false) struct_assignment_and_copy_test();
    if (false) no_decomposition_test();

    return 0;
}
