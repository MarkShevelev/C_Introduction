/**
 * Операции над числами с плавающей точкой являются неточными из-за 
 * округлений. При многократном повторении одной и той же операции 
 * ошибка округления накапливается.
 * Наиболее очевидная ситуация, когда работа с числами с плавающей 
 * точкой даёт сбой - вычисление рядов.
 * Рассмотрим гармонический ряд 1/n.
 * */

#include <stdio.h>
#include <stdbool.h>

void harmonic_series_test() {
    float curr = 0.f, next = 1.f;
    unsigned count = 2u;

    for (; count != 1000001u; ++count) {
        curr = next;
        next += 1.f/count;
    }

    printf("%u %f\n",count,next);
}

/**
 * Проблема суммирования в том, что в некоторый момент очередной член 
 * ряда настолько мал, что после суммирования округление происходит "назад", 
 * к меньшему числу, в результате теряются младшие разряды числа.
 * Классический подход для решения этой проблемы - суммирование Кэхэна.
 * Суть состоит в том, чтобы в специальной переменной сохранять младшие разряды, 
 * которые не попали в сумму.
 * */

void kahan_summation_harmonic_series_test() {
    float curr = 0.f, next = 1.f, r = 0.f; //r -специальная переменная для хранения младших разрядов
    unsigned count = 2u;

    for (; count != 1000001u; ++count) {
        curr = next;
        float y = 1.f/count - r; //добавляем младшие разряды к следующему члену последовательности
        float t = next + y;      //получаем новую сумму
        r = (t - next) - y;      //если сумма точная, то r == 0, иначе младшие разряды попадут в r
        next = t;                //переписываем значение суммы
    }

    printf("%u %f\n",count,next);
}

int main() {
    if (false) harmonic_series_test();
    if (false) kahan_summation_harmonic_series_test();
    return 0;
}